#!/usr/bin/env python3
#
#
# WIP: copy this file in wrapping/src directory of the build tree
# then execute it (python3 ./wrapping/src/poc_geometry)
#

import openmeeg as om

from enum import Enum, auto
class Orientation(Enum):
    Normal   = auto()
    Opposite = auto()

class Side(Enum):
    In     = auto()
    Out    = auto()

#
# build a geometry with given domains list
#
def make_geometry( domains_array ):
    # syntax check: need for an array of domains
    if  type(domains_array) != list:
        print("make_geometry: wrong main arg (should be an array of domains)")
        return om.Geometry()
    if len(domains_array) == 0:
        print("make_geometry: main arg is empty")
        return om.Geometry()

    for i in range(len(domains_array)):
        for dname in domains_array[i]:
            print("Domain: " + dname)

            # syntax check: need an array of interfaces
            if type(domains_array[i][dname][0]) != list:
                print("make_geometry: wrong arg for domain (" + dname + "), should be a list of interfaces")
                return om.Geometry()
            if len(domains_array[i][dname][0]) == 0:
                print("make_geometry: domain (" + dname + ") should not be empty")
                return om.Geometry()

            for j in range(len(domains_array[i][dname][0])):

                # syntax check: need a array of (msh, orientation)
                if type(domains_array[i][dname][0][j][0]) != list:
                    print("make_geometry: wrong arg for interface (" + str[j] + "), should be a list of ( mesh, orientation)")
                    return om.Geometry()
                if len(domains_array[i][dname][0][j][0]) == 0:
                    print("make_geometry: interface (" + str[j] + ") for domain (" + dname + ") should not be empty")
                    return om.Geometry()
                if domains_array[i][dname][0][j][1] != Side.In and domains_array[i][dname][0][j][1] != Side.Out:
                    print("make_geometry: wrong arg for interface (" + str[j] + "),  2nd arg should be a side direction (In/Out)")
                    return om.Geometry()


                print("- interface: " + str(j))
                for k in range(len(domains_array[i][dname][0][j][0])):
                    # syntax check: tuple of (mesh, orientation)
                    if type(domains_array[i][dname][0][j][0][k][0]) != type(om.Mesh()):
                        print("make_geometry: wrong arg for interface (" + str[j] + ") and element (" +  strk(k)+ ") 1st tuple member should a be a mesh")
                        return om.Geometry()
                    if domains_array[i][dname][0][j][0][k][1] != Orientation.Normal and domains_array[i][dname][0][j][0][k][1] != Orientation.Opposite:
                        print("make_geometry: wrong arg for interface (" + str[j] + ") and element (" +  strk(k)+ ") 2nd tuple member should a be an orientation")
                        return om.Geometry()

                    print("  - mesh       : " + domains_array[i][dname][0][j][0][k][0].name())
                    print("    " + str(len(domains_array[i][dname][0][j][0][k][0].vertices())) + " vertices")
                    print("    " + str(len(domains_array[i][dname][0][j][0][k][0].triangles())) + " triangles")
                    print("  - orientation: " + str(domains_array[i][dname][0][j][0][k][1]))


                print("- direction: " + str(domains_array[i][dname][0][j][1]))
            print("- conductivity: " + str(domains_array[i][dname][1]))
            print()

    g = om.Geometry()
    return g

#
# MIMICS Head1.geom + Head1.cond
#
m_cort = om.Mesh( "/Users/jls/Development/athena/openmeeg/data/Head1/cortex.1.tri")
m_cort.setName("cortex.1.tri")
m_skul = om.Mesh( "/Users/jls/Development/athena/openmeeg/data/Head1/skull.1.tri")
m_skul.setName("skull.1.tri")
m_scal = om.Mesh( "/Users/jls/Development/athena/openmeeg/data/Head1/scalp.1.tri")
m_scal.setName("scalp.1.tri")

# should be possible
#interface1 = [ (m1, Orientation.Normal), ( m2, Orientation.Opposite), ( m3, Orientation.Normal)]

interface1 = [ (m_cort, Orientation.Normal) ,(m_cort, Orientation.Normal) ]
interface2 = [ (m_skul, Orientation.Normal) ]
interface3 = [ (m_scal, Orientation.Normal) ]

domains = {
    "Scalp" : ( [ (interface2, Side.Out) , (interface3, Side.In) ] , 1.0 ) ,
    "Brain" : ( [ (interface1, Side.In) ] , 1.0),
    "Air"   : ( [ (interface3, Side.Out) ] , 0.0),
    "Skull" : ( [ (interface2, Side.In) , (interface1, Side.Out) ] , 0.0125)
}

g1 = make_geometry( [ domains ] );
g2 = om.Geometry()

assert g1.__class__ == g2.__class__
